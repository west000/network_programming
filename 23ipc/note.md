#进程间的通信
---
## 顺序程序和并发程序的特征
### 顺序程序
- 顺序性
- 封闭性：运行过程中运行环境（程序状态字、系统堆栈、寄存器、上下文等）不会受到其他进程影响
- 确定性
- 可再现性

### 并发程序
- 共享性：有资源在不同进程间共享
- 并发性
- 随机性

## 进程同步与进程互斥
### 进程互斥
- 由于各个进程要求共享资源，并且有些资源需要互斥使用，因此各进程间竞争使用这些资源，进程的这种关系成为进程的互斥
- 系统中某些资源一次只允许一个进程使用（排他性），称这样的资源为**临界资源**或**互斥资源**
- 在进程中涉及到互斥资源的程序段叫临界区

```
A进程		B进程
if(椅子空)	if(椅子空)
   拿走		    坐下


只有一把椅子，A和B互斥占用椅子
```

```
售票场景
票数=x

A进程		B进程
if(x>0)		if(x>0)
    x--;	    x--;

称x为临界资源，if(x>0) x--;这段代码为临界区
```

### 进程同步
- 指的是多个进程需要相互 配合共同完成一项任务
```
司机和售票员场景

司机P1			售票员P2
while(1)		while(1)
{			{
  启动车辆;	<---	  关门;
  正常行驶;		  售票;
  到站停车;	--->	  开门;
}			{
```

## 进程间通信目的
- 数据传输：
- 资源共享：
- 通知事件：一个进程需要向另一个（或一组）进程发送消息，通知它（们）发生了某种事件（如进程终止时要通知父进程）
- 进程控制：有些进程（如Debug进程）希望完全控制另一个进程的执行，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变

## 进程间通信发展
- 管道：最古老的进程通信方式，匿名管道（父子进程/亲缘进程的通信）、有名管道（同一主机内的不相关进程的通信）
- System V进程间通信（现在绝大多数*nix系统都支持System V接口，而不仅仅只有System V支持）
- POSIX进程间通信（POSIX是一种标准，给出了一些编程接口，但不限制底层实现。由于历史原因，POSIX标准的接口没有System V那么推广）

## 进程间通信分类
- 文件
- 文件锁（用于实现进程间的互斥、同步，基于读锁（共享锁）、写锁（排它锁））
- 管道（pipe）和有名管道（FIFO）（用于数据传输用的）
- 信号（signal）（用于通知事件）
- 消息队列（用于数据传输）
- 共享内存（用于数据共享）
- 信号量（用于对数据的互斥、同步访问）（System V要实现互斥量，需要通过信号量实现）
- 互斥量（互斥量、条件变量、读写锁是POSIX定义的，System V并没有）
- 条件变量
- 读写锁
- 套接字（socket）

### System V IPC
- System V 消息队列
- System V 共享内存
- System V 信号量

### POSIX IPC
- 消息队列
- 共享内存
- 信号量
- 互斥量
- 条件变量
- 读写锁

## 进程检测共享信息的3种方式
共享同一个文件系统、共享内核中的信息、共享用户空间的内存区

针对这三种情况，出现了三种IPC对象持续的方式：
- 随进程持续：一直存在直到打开的最后一个进程结束（如pipe和FIFO）
- 随内核持续：一直存在直到内核自举（即机器重启）或显式删除对象（如System V消息队列、共享内存、信号量）
- 随文件系统持续：一直存在直到显式删除，即使内核自举还存在。（POSIX消息队列、共享内存、信号量，前提是底层是使用映射文件来实现。也就是说POSIX的IPC对象，最少是随内核持续的）

## 小结
- 互斥：矛盾	椅子：两个同学抢一张椅子
- 同步：协作	公共汽车安全行驶问题：司机、售票员



# 死锁
---
死锁是指多个进程间**相互等待对方的资源**，而在得到对方资源之前又**不释放自己的资源**，这样，造成**循环等待的一种现象**。如果所有进程都在等待一个不可能发生的是，则进程就死锁了。

## 死锁产生的必要条件
- 互斥条件：进程对资源进行**排他性使用**，即在一段时间内某资源仅为**一个进程所占用**
- 请求和保持条件：当进程**因请求资源而阻塞时**，对**已获得的资源保持不放**
- 不可剥夺条件：进程已获得的资源**在未使用完之前，不能被剥夺**，只能在使用完时由自己释放
- 环路等待条件：各个进程组成**封闭的环形链**，每个进程都等待下一个进程所占用的资源

## 防止死锁的方法
- 资源一次性分配：破坏请求和保持条件
- 可剥夺资源：破坏不可剥夺条件
- 资源有序分配法：破坏循环等待条件

可见防止（预防）死锁的方法代价都很大，因此在**避免死锁**时，要施加较弱的限制，从而获得较满意的系统性能

## 避免死锁
由于在避免死锁的策略中，允许进程动态地申请资源。因而，在系统进行资源分配之前**预先计算资源分配的安全性**。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法

**银行家算法**的规定
- 当一个进程需要申请的资源总量不超过系统的资源总量时，允许进程申请资源，否则不允许申请
- 进程申请资源时，系统无法全部一次性满足，则允许进程**分批次申请资源**，但申请资源的总量不能超过系统资源总量
- 系统现有的资源数量不能满足进程本次申请的资源数量时，**可以推迟分配资源**，但要保证进程能够**在有限的时间里获得资源**
- 当进程获得所需的所有资源时，要保证能够**在有限的时间内归还资源**

## 一个产生死锁的经典问题——哲学家就餐问题
五个哲学家围在一个圆桌就餐，餐桌上有五只筷子，每个人必须拿到两只筷子才能就餐（先拿左边，再拿右边）

解决方案：
- 服务生解法：服务生相当于一个管理者
- 最多4个哲学家
- 仅当一个哲学家两边筷子都可以用时才允许他拿筷子
- 给所有哲学家编号，奇数号的哲学家必须首先拿左边筷子，偶数号哲学家则必须先拿右边筷子


## 信号量
- 互斥：P、V在同一个进程中
- 同步：P、V在不同进程中

信号量值含义：
- S>0：S表示可用资源的个数
- S=0：表示无可用资源，无等待进程
- S<0：|S|表示等待队列中进程个数

```
P(s)
{
	s.value--;
	if(s.value < 0)
	{
		该进程状态置为等待状态
		将该进程的PCB插入相应的等待队列s.queue末尾
	}
}

V(s)
{
	s.value++;
	if(s.value <= 0)
	{
		唤醒相应等待队列s.queue中等待的一个进程
		改变其状态为就绪态
		并将其插入到就绪队列中
	}
}
```

### 用PV原语解决司机与售票员问题（进程间同步问题）
```
司机进程		售票员进程
S1(0);			S2(0);
while(1)		while(1)
{			{
  P(S1)			  关门
  启动车辆		  V(S1)
  正常行驶		  售票
  到站停车		  P(S2)
  V(S2)			  开门
}			}
```

### 用PV原语解决航空售票问题（进程间互斥问题）
```
票数=x

售票进程
S(1);
P(S)
if(x>0)
  x--;
V(s)
```

