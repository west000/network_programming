# POSIX 线程
- 线程是一个进程内部的控制序列
- 一切进程至少都有一个执行线程
- 进程是资源竞争的基本单位
- 线程是程序执行的最小单位
- 线程共享进程所分配到的资源(ProcessID，[UID、GID、EUID、EGID、CWD...], Signal Dispatch Table, File Descriptors, Memory Map)
- 线程也拥有自己的一部分数据(CPU State)
  a. 线程ID(Thread ID)
  b. 一组寄存器(Registers) [IP、SP...]
  c. 栈(Kernel Stack)
  d. errno(每个线程都有自己的错误码变量)
  e. 信号状态(Signal Mask)
  f. 优先级(Priority)

## 创建新进程和新线程的区别
- 当一个进程执行执行fork调用时，会创建出进程的一个新拷贝，新进程将拥有自己的变量和PID，新进程的运行时间是独立的，它在执行时几乎完全独立于创建它的进程
- 在进程里创建一个新线程时，新的执行线程会拥有自己的堆栈（因此也有自己的局部变量），但要与它的创建者共享全局变量、文件描述符、信号处理器、当前的工作目录状态

## 线程的优点
- 线程占用的资源比进程少很多，因此创建一个新线程代价较小，线程间的切换代价也较小
- 多线程程序往往能够充分利用多处理器的可并行数量
- 在等待慢速I/O操作结束的同时，程序可以切换到其他线程，执行其他计算任务
- 计算密集型应用：将计算分解到多个线程中实现，充分利用多核处理器
- I/O密集型应用：为了提高性能，将I/O操作重叠。不同线程可以同时等待不同的I/O操作

## 线程的缺点
- 性能损失：比如，一个很少被外部事件阻塞的计算密集型线程往往无法与其他线程共享同一个处理器。若果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失（即增加了额外的同步和调度开销，但可用的资源数量不变）
- 健壮性降低：在多线程程序里，因为时间分配上的细微偏差，或者因为共享了不该共享的变量（相比与进程间内存访问受到MMU控制，同一个进程中的线程相互间不设防），可能造成不良的影响
- 缺乏访问控制：进程是访问控制的基本粒度，在一个线程中调用某些OS函数时，会对整个进程内的所有线程造成影响。比如，一个线程修改进程当前的工作目录状态（CWD），其他线程也会受到影响
- 编程难度高

## 线程调度竞争范围（thread-scheduling contention scope）
操作系统提供的不同模型用于调度线程，这些模型的主要区别是：在竞争系统资源（特别是CPU时间）时，线程调度竞争范围不同
- 进程竞争范围（process contention scope）：各个线程在同一进程竞争"被调度的CPU时间"，不直接与其他进程中的线程竞争
- 系统竞争范围（system contention scope）：线程直接和"系统范围"内的其他线程竞争

## 线程模型
- N:1用户线程模型
- 1:1核心线程模型
- N:M混合线程模型

### N:1用户线程模型
- 早期线程的实现方式，N个用户线程 映射到 1个内核线程
- 这些线程都工作在`进程竞争范围`
- 由用户空间的程序库管理线程的创建、调度、销毁，因而开销较小
- 内核完全不知道线程的信息
- 这种模型的缺点有：
  a. 一个进程内的多个线程只能调度到一个CPU，这限制了可用的并行总量
  b. 某个线程阻塞了（如调用read），那么进程中的所有线程都会阻塞，直到阻塞操作返回。为此，一些线程的实现是为这些阻塞式函数提供包装器，用非阻塞版本替换此类系统调用，以消除这种限制，但这往往不可移植

### 1:1核心线程模型
- 用户程序创建的每一个线程，都由一个核心线程直接管理
- 所有线程都工作在`系统竞争范围`
- 线程的创建、调度由内核完成，因此开销较大（但一般比进程开销小）

### N:M混合线程模型
- POSIX线程的实现模型
- 提供两级控制，先将用户线程映射到轻量级进程(LWP:ligtweight process)以实现并行，LWP在一一映射到核心线程
- 结合了上面两种模型的优点
  a. 多个用户线程映射到LWP，用户线程创建、调度开销比较小
  b. LWP一一映射到内核线程，能够利用多核CPU的优势

