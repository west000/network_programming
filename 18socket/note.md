# select的限制
1. 一个进程所能够打开的最大文件描述符个数是有限的
2. FD_SETSIZE的限制(fd_set)

# poll
1. 一个进程所能够打开的最大文件描述符个数是有限的

ulimit -n number可以修改进程可以打开的最大文件描述符个数
但是系统所有打开的文件描述符个数是有限的（受到内存大小的限制）
查看系统所能打开的文件个数：cat /proc/sys/fs/file-max

# select和poll的相同点
1. 内核要遍历所有的文件描述符，直到找到发生事件的文件描述符。当文件描述符个数增长的时候，性能线性下降,甚至会达到一定数量时，性能会呈指数下降

# epoll与select、poll的区别
1. 相比于select/poll，epoll最大的好处在于它不会随着监听fd数目的增加而降低效率
2. 内核中的select/poll的实现是采用轮询来处理的，轮询的fd数目越多，耗时越长
3. epoll的实现是基于回调的，如果fd有期望的事件发生，就通过回调函数将其加入epoll就绪队列中，即epoll实例只关心“活跃”的fd，不需要遍历不活跃的fd
4. 当select/poll检测到期望的事件，它要将描述符的信息从内核空间拷贝到用户空间，去通知用户；而epoll采用共享内存的方式
5. epoll不仅会告诉应用程序有I/O事件到来(通过epoll_wait返回值通知)，还有告诉应用程序相关的信息（将信息存放到epoll_event数组中返回给应用），这些信息是应用程序填充的(填充epoll_event中的event和data，data是一个联合体，可以根据需要填充更加丰富的数据)，因此根据这些信息音乐相册就能直接定位到事件，而不需要遍历整个fd集合

# epoll的两种模式
## EPOLLLT(水平触发)

## EPOLLET(边沿触发)
- 当事件状态从空闲转变为就绪时，epoll就会通知应用程序
- 一旦fd变成就绪状态，epoll将不再关注这个fd的任何状态信息（将该fd从epoll队列中移除），直到应用程序通过读写操作触发EAGAIN状态（前提是fd必须设置为非阻塞模式，同时读写操作完成了，才会触发EAGAIN），这时epoll才会认为这个fd的状态从就绪变为空闲，于是epoll又重新关注这个fd的状态（将该fd加入epoll队列）
- 随着epoll_wait的返回，队列中的fds是在减少的，所以在大并发的系统中，EPOLLET更加有优势

- 实际编程中，可以设置fd为O_NONBLOCK，当epoll_wait返回时，我们对fd进行读写，可以采用while(1)循环读写，直到触发EAGAIN，表明读写已经完成，跳出循环

